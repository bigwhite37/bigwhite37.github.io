<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>[笔记] Huge pages part 2 (Interfaces) | </title><meta name="description" content="[笔记] Huge pages part 2 (Interfaces) - bigwhite37"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title=""><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title=""></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/bigwhite37" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about" target="_self">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">[笔记] Huge pages part 2 (Interfaces)</h1><div class="post-info"><a></a>2021-04-19</div><div class="post-content"><blockquote>
<p>原文：</p>
<p><a target="_blank" rel="noopener" href="https://lwn.net/Articles/375096/"><em>Huge pages part 2 (Interfaces)</em></a></p>
</blockquote>
<h2 id="1-Shared-Memory"><a href="#1-Shared-Memory" class="headerlink" title="1 Shared Memory"></a>1 <em>Shared Memory</em></h2><p>最老的方法之一是调用 <code>shmget()</code> 在 <em>huge page</em> 上创建共享内存段。现在仍使用该方法的原因是简单，且支持时间长。使用 <em>huge page</em> 时指定 <code>SHM_HUGETLB</code> 标志，并确保共享内存大小是 <em>huge-page-aligned</em>。例子见 <a target="_blank" rel="noopener" href="https://lwn.net/Articles/375098/"><em>Documentation/vm/hugetlbpage.txt</em></a>。</p>
<p>该接口的限制是其仅能使用默认 <em>huge page size</em>（<code>/proc/meminfo</code> 中 <code>Hugepagesize</code> 字段）。如果想使用 <em>POWER</em> 支持的 <em>16GB</em> 页，则只能通过 <em>kernel command line</em> 设置 <code>default_hugepagesz=</code> 字段实现，一如 <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.txt#L874"><em>Documentation/admin-guide/kernel-parameters.txt</em></a> 里所描述的一样。</p>
<blockquote>
<p><em>default_hugepagesz=</em></p>
<p><em>[HW] The size of the default HugeTLB page. This is the size represented by the legacy</em> <code>/proc/</code> <em>hugepages APIs.  In addition, this is the default hugetlb size used for</em> <code>shmget()</code>, <code>mmap()</code> <em>and mounting hugetlbfs filesystems.  If not specified, defaults to the architecture’s default huge page size.  Huge page sizes are architecture dependent.  See also Documentation/admin-guide/mm/hugetlbpage.rst. Format: size[KMG]</em></p>
</blockquote>
<p><em>shared-memory huge page</em> 所能使用的最大内存由 <em>sysctl</em> 参数 <code>shmmax</code> 控制。该参数留待后文讨论。</p>
<h2 id="2-HugeTLBFS"><a href="#2-HugeTLBFS" class="headerlink" title="2 HugeTLBFS"></a>2 <em>HugeTLBFS</em></h2><p>为创建 <em>shared or private mapping</em>，<em>Linux</em> 提供了 <em>RAM-based</em> 文件系统，名为 <em>hugetlbfs</em>。该文件系统上的每个文件均落在 <em>huge page</em> 里，可以通过 <code>mmap()</code> 或 <code>read()</code> 访问。若在挂载时为指定参数，则使用默认 <em>huge page size</em>。使用 <code>pagesize=</code> 指定 <em>huge page size</em>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount -t hugetlbfs none /mnt/hugetlbfs -o pagesize=64K</span><br></pre></td></tr></table></figure>

<p>有两种方式控制 <em>attach</em> 到挂载点上的 <em>huge page</em> 所消耗的内存大小：</p>
<ol>
<li><code>size=</code> 指定该挂载文件最大可消耗内存，该 <em>size</em> 向下取整到最接近的 <em>huge page size</em></li>
<li><code>nr_inodes=</code> 限制挂载点可创建的最大文件数，实际上是限制了映射的数量。</li>
</ol>
<p>结合使用这些选项，可将 <em>huge page</em> 分配给共享系统中的组或用户。</p>
<p>对于希望通过 <em>API</em> 访问 <em>huge page</em> 的应用，首先需要通过读取 <code>/proc/mounts</code> 发现挂载点，这一步亦可借由 <em>libhugetlbfs</em> 完成。手动发现挂载点的方式相对直接（<em>debugfs</em> 就是这样用的），下例给出该方式的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">find_hugetlbfs</span><span class="params">(<span class="keyword">char</span> *fsmount, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> format[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> fstype[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">char</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *fd;</span><br><span class="line"></span><br><span class="line">    snprinft(format, <span class="number">255</span>, <span class="string">&quot;%%*s %%%ds %%255s %%*s %%*d %%*d&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/mounts&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fd) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fd, format, fsmount, fstype) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fstype, <span class="string">&quot;hugetlbfs&quot;</span>)) &#123;</span><br><span class="line">            ret = fsmount;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(fd);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[PATH_MAX+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hugetlbfs mounted at %s\n&quot;</span>, find_hugetlbfs(buffer, PATH_MAX));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有多个挂载点时（使用不同的 <em>page size</em>）将更为复杂。<em>libhugetlbfs</em> 提供了几个函数来解决这一问题。<code>hugetlbfs_find_path()</code> 返回挂载点，与上面程序类似。<code>hugetlbfs_find_path_for_size()</code> 将返回指定大小的 <em>huge page</em>。如果开发者希望测试特定路径是否是 <em>hugetlbfs</em>，可以使用 <code>hugetlbfs_test_path()</code>。</p>
<h2 id="3-Anonymous-mmap"><a href="#3-Anonymous-mmap" class="headerlink" title="3 Anonymous mmap()"></a>3 <em>Anonymous mmap()</em></h2><p>自 <em>2.6.32</em> 起，调用 <code>mmap()</code> 时，指定 <code>MAP_ANONYMOUS|MAP_HUGETLB</code> 可以在 <em>huge page</em> 上创建匿名映射（<em>private or shared</em>）。匿名 <code>mmap()</code> 可用的内存仅受限于 <em>huge page</em> 可用的数量，这在某种程度上是一种疏忽。这一潜在问题可能会在未来的内核版本里解决。</p>
<h2 id="4-libhugetlbfs-Allocation-APIs"><a href="#4-libhugetlbfs-Allocation-APIs" class="headerlink" title="4 libhugetlbfs Allocation APIs"></a>4 <em>libhugetlbfs Allocation APIs</em></h2><p>有时，一些应用仅想简单的从 <em>huge page</em> 上拿到一块 <em>buffer</em>。为此，自 <em>2.0</em> 起，<em>libhugetlbfs</em> 提供了两个 <em>API</em>：<code>get_hugepage_region()</code> 和 <code>get_huge_pages()</code>，其对应的 <em>free</em> 函数为：<code>free_hugepage_region()</code> 和 <code>free_huge_pages()</code>。</p>
<p><code>get_huge_pages()</code> 一般用于自定义的 <em>allocator</em>，但不能直接替代 <code>malloc()</code>。该 <em>API</em> 的 <em>size</em> 参数需是 <em>hugepage-aligned</em>（可以通过 <code>gethugepagesize()</code> 获取）。</p>
<p>如果应用想 <em>allocate</em> 一块非常大的 <em>buffer</em>，且不考虑对齐和浪费问题，应该使用 <code>get_hugepage_region()</code>。该 <em>API</em> 更为宽松且在必要时会退回使用 <em>small page</em>。</p>
<p>如果应用对希望严格控制映射于何处放置于内存上，<em>libhugetlbfs</em> 提供了两个 <em>API</em>：<code>hugetlbfs_unlinked_fd()</code> 和 <code>hugetlbfs_unlinked_fd_for_size()</code>，用于在适当的 <em>hugetlbfs</em> 挂载点上创建 <em>unlinked</em> 文件描述符。使用该描述符，应用可以使用适当参数调用 <code>mmap()</code>，精确控制映射的位置。</p>
<h2 id="5-Automatic-Backing-of-Memory-Regions"><a href="#5-Automatic-Backing-of-Memory-Regions" class="headerlink" title="5 Automatic Backing of Memory Regions"></a>5 <em>Automatic Backing of Memory Regions</em></h2><p><em>libhugetlbfs</em> 可以自动以数种内存区域类型作为后端，无论其是 <em>pre-linked</em> 还是 <em>pre-loaded</em>。文档见 <em>libhugetlbfs</em> 的 <em>HOWTO</em> 和手册页。</p>
<p><em>libhugetlbfs</em> 的行为由 <em>libhugetlbfs.7</em> 里的环境变量描述。由于处理环境变量既耗时又容易出错，因此 <code>hugectl</code> 应运而生，用于处理配置工作，使用 <code>--dry-run</code> 选项会打印出将要做的操作。</p>
<p>为确定是否是真的在用 <em>huge page</em>，可检查 <code>/proc</code>，但 <em>libhugetlbfs</em> 也会在 <em>verbosity</em> 足够高、<em>huge page</em> 不足时发出警告。下面给出了使用 <em>huge page</em> 的 <em>32MB</em> 段作为后端的程序。请注意第一次尝试使用 <em>huge page</em> 是如何失败的，并且因为在此系统上没有配置过 <em>huge page</em>，所以做了一些配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ./hugetlbfs-shmget-test</span><br><span class="line">shmid: 0x2130007</span><br><span class="line">shmaddr: 0xb5e37000</span><br><span class="line">Starting the writes: ................................</span><br><span class="line">Starting the Check...Done.</span><br><span class="line"></span><br><span class="line">$ hugectl --shm ./hugetlbfs-shmget-test</span><br><span class="line">libhugetlbfs: WARNING: While overriding shmget(33554432) to add</span><br><span class="line">                        SHM_HUGETLB: Cannot allocate memory</span><br><span class="line">libhugetlbfs: WARNING: Using small pages <span class="keyword">for</span> shmget despite</span><br><span class="line">                        HUGETLB_SHM shmid: 0x2128007</span><br><span class="line">shmaddr: 0xb5d57000</span><br><span class="line">Starting the writes: ................................</span><br><span class="line">Starting the Check...Done.</span><br><span class="line"></span><br><span class="line">$ hugeadm --pool-pages-min 4M:32M</span><br><span class="line">$ hugectl --shm ./hugetlbfs-shmget-test</span><br><span class="line">shmid: 0x2158007</span><br><span class="line">shmaddr: 0xb5c00000</span><br><span class="line">Starting the writes: ................................</span><br><span class="line">Starting the Check...Done.</span><br></pre></td></tr></table></figure>

<h3 id="5-1-Shared-Memory"><a href="#5-1-Shared-Memory" class="headerlink" title="5.1 Shared Memory"></a>5.1 <em>Shared Memory</em></h3><p>当预加载或链接 <em>libhugetlbfs</em> 时，环境变量 <code>HUGETLB_SHM</code> 设为 <code>yes</code>，<em>libhugetlbfs</em> 将重载所有对 <code>shmget()</code> 的调用。或者以 <code>hugectl $--$shm</code> 方式加载应用程序。在起始阶段，所有 <code>shmget()</code> 请求将以 <em>huge page</em> 边界对齐，并以 <em>huge page</em> 作为后端。如果系统配置不允许使用 <em>huge page</em>，则使用原调用。</p>
<h3 id="5-2-Heap"><a href="#5-2-Heap" class="headerlink" title="5.2 Heap"></a>5.2 <em>Heap</em></h3><p><em>glibc</em> 给出了 <code>__morecore</code> <em>hook</em>，会在 <em>heap size</em> 增加时调用。<em>libhugetlbfs</em> 使用该 <em>hook</em> 创建以 <em>huge page</em> 为后端的内存。与共享内存相似，<em>huge page</em> 不可用时，使用 <em>base page</em>。</p>
<p>当预加载或链接 <em>libhugetlbfs</em> 时，环境变量 <code>HUGETLB_MORECORE</code> 设为 <code>yes</code>，<em>libhugetlbfs</em> 会配置 <code>__morecore</code> <em>hook</em>，使 <code>malloc()</code> 使用 <em>huge page</em>。或者以 <code>hugectl --heap</code> 方式启动应用。</p>
<p>而与共享内存不同的是，如果系统支持多个 <em>page size</em>，则可以指定 <em>page size</em>。下面的第一个例子使用默认 <em>page size</em>，第二个例子使用 <em>64K</em> 页：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hugectl --heap ./target-application</span><br><span class="line">$ hugectl --heap=64K ./target-application</span><br></pre></td></tr></table></figure>

<p>如果应用程序以及链接了 <em>libhugetlbfs</em>，则在使用 <code>--heap</code> 时可能需要指定 <code>--no-preload</code>，以便不会两次尝试加载 <em>lib</em>。</p>
<p>使用 <code>__morecore</code> <em>hook</em> 时，设置 <code>mallopt()</code> 选项 <code>M_MMAP_MAX</code> 为 <em>0</em>，<em>libhugetlbfs</em> 会阻止 <em>glibc</em> 使用 <code>brk()</code> 扩展堆。而直接调用 <code>brk()</code> 的应用会使用 <em>base page</em>。</p>
<p>如果使用自定义 <em>allocator</em>，为使用 <em>huge page</em>，其必须支持 <code>__morecore</code>。或者针对 <code>malloc()</code> 进行封装，内部依据缓存大小调用 <code>malloc()</code> 或 <code>get_hugepage_region()</code>。另一个重量级解决方案是使用 <em>libhugetlbfs</em> 提供 <code>malloc()</code> 的完整实现，在适当的情况下使用 <em>huge page</em>，不过该方案由于缺少可验证的使用案例，暂时不可用。</p>
<h3 id="5-3-Text-and-Data"><a href="#5-3-Text-and-Data" class="headerlink" title="5.3 Text and Data"></a>5.3 <em>Text and Data</em></h3><p><em>backing text or data</em> 更复杂，应用需要先 <em>relink</em> 将 <em>section</em> 以 <em>huge page</em> 边界对齐。为此，需要链接 <em>libhugetlbfs</em>，并指定 <code>-Wl,--hugetlbfs-align</code>，不过前提是 <em>libhugetlbfs</em> 是最近的发行版本。详细描述见 <em>libhugetlbfs</em> 的 <em>HOWTO</em>。当应用 <em>relink</em> 后，则一如前文所述，其行为受控于相关环境变量或 <code>hugectl</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hugectl --text --data --bss ./target-application</span><br></pre></td></tr></table></figure>

<p>当 <em>backing text or data</em> 时，相关 <em>section</em> 将复制进 <em>hugetlbfs</em> 文件系统里的文件里，并由 <code>mmap()</code> 映射进内存。接着，<em>unlink</em> 这些文件一遍在应用退出前释放这些内存。如果应用运行多次，则可以通过 <code>--share-text</code> 共享这段数据（在应用退出后该内存依旧可用，所以必须手动释放）。</p>
<p>如果不能 <em>relink</em> 应用，则可以通过设置环境变量 <code>HUGETLB_FORCE_ELFMAP</code> 为 <code>yes</code> 强制载入以 <em>huge page</em> 为后端的段。不过该方法不保证成功。载入的段必须足够大，可以覆盖整个 <em>huge page</em>，以及依架构而定，段可能被替换，这也是问题之一。</p>
<h3 id="5-4-Stack"><a href="#5-4-Stack" class="headerlink" title="5.4 Stack"></a>5.4 <em>Stack</em></h3><p><em>stack</em> 当前不能以 <em>huge page</em> 为后端。以前有实现过该功能，但应用并没有重度使用 <em>stack</em>。在多数发行版本里，<code>ulimits</code> 对 <em>stack</em> 的最大限制要小于 <em>huge page size</em>。经实践，仅 <em>SPEC CPU 2006</em> 里的 <em>bwaves</em> 测试从 <em>huge page stack</em> 中获益，且还是在使用商用编译器的情况下。当使用 <em>gcc</em> 编译后，并无性能提升，因此针对 <em>stack</em> 的支持就砍了。</p>
</div></article></div></main><footer><div class="paginator"><a class="next" href="/2021/04/19/Huge-pages-part-1-Introduction-%E7%AC%94%E8%AE%B0/">next</a></div><div class="copyright"><p>&copy; 2021 <a target="_blank" rel="noopener" href="https://github.com/bigwhite37">bigwhite37</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>