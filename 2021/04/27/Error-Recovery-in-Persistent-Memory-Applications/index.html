<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>[笔记] Error Recovery in Persistent Memory Applications | </title><meta name="description" content="[笔记] Error Recovery in Persistent Memory Applications - bigwhite37"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title=""><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
</head><body><div class="wrap"><header><h1 class="branding"><a href="/" title=""></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/bigwhite37" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about" target="_self">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">[笔记] Error Recovery in Persistent Memory Applications</h1><div class="post-info"><a></a>2021-04-27</div><div class="post-content"><blockquote>
<p>原文：</p>
<p><a target="_blank" rel="noopener" href="https://software.intel.com/content/www/us/en/develop/articles/error-recovery-in-persistent-memory-applications.html"><em>Error Recovery in Persistent Memory Applications</em></a></p>
</blockquote>
<h2 id="1-Memory-Errors-for-Mapped-Memory"><a href="#1-Memory-Errors-for-Mapped-Memory" class="headerlink" title="1 Memory Errors for Mapped Memory"></a>1 <em>Memory Errors for Mapped Memory</em></h2><p>出现内存错误时，可能会发生两种事——不可恢复的 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8"><em>machine check</em></a> 或是可恢复的 <em>machine check</em>。可恢复 <em>machine check</em> 发生时，操作系统向应用发送 <code>SIGBUS</code> 信号。</p>
<p>虽然捕获 <code>SIGBUS</code> 可行，但对于大多数应用程序来说，这样做太容易出错，因此用处不大。对 <em>persistent memory</em> 而言，应用正确的做法应该是挂掉然后重启。</p>
<p>不过对于 <em>persistent memory</em> 而言，仅简单重启应用并不管用。对 <em>volatile memory</em> 来说，操作系统会将受影响的物理页移出可用物理页池。之所以能这样做是因为 <em>volatile memory</em> 在 <em>allocate</em> 之前没状态。然后在 <em>persistent memory</em> 上则不然，应用告诉操作系统对那些内存页做映射，这些内存页通常是预分配的，存储着一些有意义的数据。如果应用因为 <em>persistent memory</em> 上的内存错误而重启，则其会再次碰上这个错误，然后重复这一流程。</p>
<h3 id="1-1-Discovering-Bad-Blocks"><a href="#1-1-Discovering-Bad-Blocks" class="headerlink" title="1.1 Discovering Bad Blocks"></a>1.1 <em>Discovering Bad Blocks</em></h3><p>如果应用因内存错误挂掉，则会出现如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bus error (core dumped)</span><br></pre></td></tr></table></figure>

<p>再次之后，出问题的块会标记为 <em>bad</em>。如果应用使用的是经 <em>PMDK</em> 创建的 <em>pool</em>，可以用 <code>pmempool info</code> 检查：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pmempool info --bad-blocks=yes /mnt/pmem1/pmem-file</span><br><span class="line">Part file:</span><br><span class="line">path                     : /mnt/pmem1/pmem-file</span><br><span class="line"><span class="built_in">type</span>                     : regular file</span><br><span class="line">size                     : 16777216</span><br><span class="line">bad blocks:</span><br><span class="line">        offset          length</span><br><span class="line">        96              8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：对于 <code>ndctl</code> 创建的 <em>namespace</em> 下的设备，块大小总是 <em>512</em> 字节。</p>
</blockquote>
<p>对于 <em>devdax</em> 设备也一样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ pmempool info --bad-blocks=yes /dev/dax0.0</span><br><span class="line">Part file:</span><br><span class="line">path                     : /dev/dax0.0</span><br><span class="line"><span class="built_in">type</span>                     : device dax</span><br><span class="line">size                     : 811746721792</span><br><span class="line">alignment                : 2097152</span><br><span class="line">bad blocks:</span><br><span class="line">        offset          length</span><br><span class="line">        96              1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果没使用 <em>PMDK pool</em>，则需要按 <em>namespace</em> 找出坏块，并根据其偏移量算出其在文件里的相对偏移。对于 <em>devdax</em>，无文件系统，所以相对偏移即全局偏移。如下所示与上例等同：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ndctl list --media-errors</span><br><span class="line">[</span><br><span class="line">  ...</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>:<span class="string">&quot;namespace0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mode&quot;</span>:<span class="string">&quot;devdax&quot;</span>,</span><br><span class="line">    <span class="string">&quot;map&quot;</span>:<span class="string">&quot;mem&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;badblock_count&quot;</span>:1,</span><br><span class="line">    <span class="string">&quot;badblocks&quot;</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;offset&quot;</span>:96,</span><br><span class="line">        <span class="string">&quot;length&quot;</span>:1,</span><br><span class="line">        <span class="string">&quot;dimms&quot;</span>:[</span><br><span class="line">          <span class="string">&quot;nmem2&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>但对于 <em>fsdax</em> 则不同：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ndctl list --media-errors</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>:<span class="string">&quot;namespace1.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mode&quot;</span>:<span class="string">&quot;fsdax&quot;</span>,</span><br><span class="line">    <span class="string">&quot;map&quot;</span>:<span class="string">&quot;mem&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;badblock_count&quot;</span>:1,</span><br><span class="line">    <span class="string">&quot;badblocks&quot;</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;offset&quot;</span>:295008,</span><br><span class="line">        <span class="string">&quot;length&quot;</span>:1,</span><br><span class="line">        <span class="string">&quot;dimms&quot;</span>:[</span><br><span class="line">          <span class="string">&quot;nmem8&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>filefrag</code> 算出相对偏移：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ filefrag -v -b512 /mnt/pmem1/pmem-file</span><br><span class="line">Filesystem <span class="built_in">type</span> is: ef53</span><br><span class="line">File size of /mnt/pmem1/pmem-file is 16777216 (32768 blocks of 512 bytes)</span><br><span class="line">ext:     logical_offset:        physical_offset: length:   expected: flags:</span><br><span class="line">  0:        0..   16383:     294912..    311295:  16384:</span><br><span class="line">  1:    16384..   32767:     311296..    327679:  16384:             last,unwritten,eof</span><br><span class="line">/mnt/pmem1/pmem-file: 1 extent found</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>We pass -b512 for block size of 512 bytes, and -v for verbose. We can see that the file has two extends of 16384 blocks each. The first extend corresponds to the logical (relative) offsets 0-16383 and physical offsets 294912-311295. Physical offsets are what interests us here. If we subtract 294912 from 295008, we get exactly 96.</em></p>
</blockquote>
<h3 id="1-2-Fixing-Bad-Blocks"><a href="#1-2-Fixing-Bad-Blocks" class="headerlink" title="1.2 Fixing Bad Blocks"></a>1.2 <em>Fixing Bad Blocks</em></h3><p>清理坏块时，寻找设备上健康的物理块，将坏块上的映射重新映射到健康的物理块上。这一过程称为 <em>clear the poison</em>。从应用视角来看，该过程借备份恢复丢失的数据。在 <em>fsdax</em> 模式里，即用备份数据覆盖 <em>pool</em> 文件。如果 <em>pool</em> 很大（如：太字节），或者使用了 <em>daxdev</em> 模式，则仅覆盖收影响的块。</p>
<p>应用程序只覆盖（即修复）受影响的块的建议逻辑如下：</p>
<ol>
<li>如果上一次修复操作中断了，见 <em>3</em>。</li>
<li>持久化记录哪一部分（<em>offset + length</em>）在修复。</li>
<li><em>clear the poison</em><ul>
<li><em>devdax</em> 设备：直接以 <em>0</em> 初始化受影响的块</li>
<li><em>fsdax</em> 设备：<em>deallocate</em> 并重新 <em>allocate</em> 受影响的块。该操作会以 <em>0</em> 初始化这些块</li>
</ul>
</li>
<li>复制副本数据写入这些块。</li>
<li>删除表示正在修复的持久化记录。</li>
</ol>
<p>如果不可恢复，则不执行第 <em>4</em> 步。如果应用使用 <em>PMDK</em> 创建 <em>pool</em>，且 <em>pool</em> 的元数据损坏，则使用 <code>pmempool check</code> 有机会恢复。未检出元数据是否损毁，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pmempool check -v /mnt/pmem1/poolfile</span><br><span class="line">checking pool header</span><br><span class="line">incorrect pool header</span><br><span class="line">/mnt/pmem1/poolfile: not consistent</span><br></pre></td></tr></table></figure>

<p>尝试修复时，使用 <code>-r</code> 和 <code>-a</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pmempool check -v -r -a /mnt/pmem1/poolfile</span><br><span class="line">...</span><br><span class="line">/mnt/pmem1/poolfile: repaired</span><br></pre></td></tr></table></figure>

<p>更详细的见 <a target="_blank" rel="noopener" href="https://software.intel.com/content/www/us/en/develop/articles/recovery-and-fault-tolerance-for-persistent-memory-pools-using-persistent-memory.html"><em>Recovery and Fault-Tolerance for Persistent Memory Pools Using Persistent Memory Development Kit (PMDK)</em></a>。</p>
<p>最后，也可用用 <code>pmempool sync</code> 进行恢复：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pmempool sync --bad-blocks ./poolset.file</span><br></pre></td></tr></table></figure>

<p>该命令仅可用于 <em>replica pool set</em>，详见 <a target="_blank" rel="noopener" href="https://pmem.io/pmdk/manpages/linux/v1.4/poolset/poolset.5"><em>poolset man page</em></a>。</p>
<h3 id="1-3-Clearing-the-Poison"><a href="#1-3-Clearing-the-Poison" class="headerlink" title="1.3 Clearing the Poison"></a>1.3 <em>Clearing the Poison</em></h3><h4 id="1-3-1-Devdax"><a href="#1-3-1-Devdax" class="headerlink" title="1.3.1 Devdax"></a>1.3.1 <em>Devdax</em></h4><p>我们可以使用 <code>ndctl</code> 或 <code>daxio</code> 对 <em>devdax</em> 设备 <em>clear the poison</em>，后者在决定哪些数据可以写入设备上更为灵活。</p>
<p>使用 <code>ndctl</code> 以 <em>0</em> 初始化 <em>namespace0.0 (device /dev/dax0.0)</em> 上受影响的块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ndctl clear-errors namespace0.0</span><br></pre></td></tr></table></figure>

<p>下例是使用 <code>daxio</code> 做同样的事，但一次仅针对一个偏移量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ daxio --output=/dev/dax0.0 --zero --seek=96 --len=512</span><br><span class="line">daxio: copied 512 bytes to device <span class="string">&quot;/dev/dax0.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以用 <code>--input</code> 指定输入文件来替代 <code>--zero</code>。</p>
<blockquote>
<p>注意：不支持使用 <code>dd</code> 或 <code>write()</code> 直接向 <code>/dev/dax0.0</code> 写入来清空块。<em>devdax</em> 支持有限，仅可以通过内存映射进行读写。</p>
</blockquote>
<h4 id="1-3-2-Fsdax"><a href="#1-3-2-Fsdax" class="headerlink" title="1.3.2 Fsdax"></a>1.3.2 <em>Fsdax</em></h4><p>为了可以 <em>deallocate</em> 后再 <em>allocate</em>，我们使用 <code>fallocate</code>。</p>
<blockquote>
<p>注意：在调用 <code>fallocate</code> 前直接使用 <code>dd</code> 或 <code>write()</code>写坏块会出现 Input/Output error (EIO)。原因是 <em>persistent memory aware</em> 文件系统会检查坏块并在对坏块读写前返回 <em>EIO</em>。</p>
</blockquote>
<p>在指定偏移处 <em>deallocate/allocate</em>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ fallocate --punch-hole -o 49152 -l 512 --keep-size /mnt/pmem1/pmem-file</span><br><span class="line">$ fallocate -o 49152 -l 512 --keep-size /mnt/pmem1/pmem-file</span><br></pre></td></tr></table></figure>

<p><em>fallocate</em> 运行时，需要以字节为单位制定偏移和长度。上例中，<em>96 x 512 = 49152</em>。也可以通过编程实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">fd = open (filename, O_RDWR);</span><br><span class="line">fallocate (fd, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, offset, length);</span><br><span class="line">fallocate (fd, FALLOC_FL_KEEP_SIZE, offset, length);</span><br><span class="line">close (fd);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：别用 <code>dd</code> 或 <code>write()</code> 直接写运行着文件系统的设备（如：<code>/dev/pmem1</code>）来清理块。这样做可能会损坏文件系统。</p>
</blockquote>
<p>如果可以先 <em>unmount</em> 文件系统，则可以向在 <em>devdax</em> 里那样使用 <code>ndctl</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ndctl clear-errors namespace1.0</span><br></pre></td></tr></table></figure>

<h3 id="1-4-Bad-Block-Injection"><a href="#1-4-Bad-Block-Injection" class="headerlink" title="1.4 Bad Block Injection"></a>1.4 <em>Bad Block Injection</em></h3><p>为测试应用健壮性，可以使用 <code>ndctl</code> 注入坏块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ndctl inject-error --block=295008 --count=1 namespace1.0</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>filefrag</code> 找注入的坏块（见 <em>Discovering Bad Blocks</em>）。检查注入是否成功，使用 <code>--status</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ndctl inject-error --status namespace1.0</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;badblocks&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;block&quot;</span>:295008,</span><br><span class="line">      <span class="string">&quot;count&quot;</span>:1</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次之后，<code>mmap()</code> 虽然不会失败，但如果常熟读取受影响的块，操作系统则会发送 <code>SIGBUS</code> 信号。</p>
<p>移除注入的坏块是可能的。但是如果在移除之前操作系统检查到了坏块，则移除命令不能使操作系统遗忘注入的坏块。这时只能根据上面的章节修复坏块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ndctl inject-error --uninject --block=295008 --count=1 namespace1.0</span><br><span class="line">Warning: Un-injecting previously injected errors here will</span><br><span class="line">not cause the kernel to <span class="string">&#x27;forget&#x27;</span> its badblock entries. Those</span><br><span class="line">have to be cleared through the normal process of writing</span><br><span class="line">the affected blocks</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>:<span class="string">&quot;namespace1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;mode&quot;</span>:<span class="string">&quot;fsdax&quot;</span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="2-Unsafe-Shutdowns"><a href="#2-Unsafe-Shutdowns" class="headerlink" title="2 Unsafe Shutdowns"></a>2 <em>Unsafe Shutdowns</em></h2><p><strong>从 <em>CPU cache flush</em> 数据并不意味着这些数据一定已经写到持久化介质上。在此之前，这些数据会在 <em>memory controller (MC)</em> 的写队列上停留一段时间。</strong></p>
<p>为避免丢失数据，<em>MC</em> 队列受 <em>Asynchronous DRAM Refresh (ADR)</em> 保护。就 <em>Intel® Optane™ Persistent Memory</em> 模块而言，<em>ADR</em> 保证在掉电时，所有 <em>MC</em> 队列里的数据会写入持久化介质里。<em>ADR</em> 同时也设置了 <em>DRAM</em> 的自刷新，确保数据正确备份到正确的其他持久化内存上，如 *non-volatile dual in-line memory modules (NVDIMMs)*。</p>
<p><strong>尽管很罕见，但 <em>ADR</em> 也可能会失败</strong>。例如，当机房的取暖、通风和空调（<em>Heating, Ventilation, and Air Conditioning, HVAC</em>）系统停机时，由于温度过高，<em>CPU</em> 减速，现存电量不足以使 <em>ADR</em> 完成 <em>flush</em> 数据。<em>ADR</em> 的失败产生了 <em>unsafe shutdown</em>。不幸的是，在 <em>unsafe shutdown</em> 后没办法知道哪部分损坏，哪部分没损坏，并不存在一份关于受影响文件或块的列表。发生了 <em>unsafe shutdown</em>，推荐的做法是删除数据并从备份恢复，如果可以的话。</p>
<h3 id="2-1-Discovering-Unsafe-Shutdowns"><a href="#2-1-Discovering-Unsafe-Shutdowns" class="headerlink" title="2.1 Discovering Unsafe Shutdowns"></a>2.1 <em>Discovering Unsafe Shutdowns</em></h3><p>使用 <code>ndctl</code> 检查监控状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ ndctl list -DH</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>:<span class="string">&quot;nmem1&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;health&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;health_state&quot;</span>:<span class="string">&quot;ok&quot;</span>,</span><br><span class="line">      <span class="string">&quot;temperature_celsius&quot;</span>:31.0,</span><br><span class="line">      <span class="string">&quot;controller_temperature_celsius&quot;</span>:33.0,</span><br><span class="line">      <span class="string">&quot;spares_percentage&quot;</span>:100,</span><br><span class="line">      <span class="string">&quot;alarm_temperature&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;alarm_controller_temperature&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;alarm_spares&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;alarm_enabled_media_temperature&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;temperature_threshold&quot;</span>:82.0,</span><br><span class="line">      <span class="string">&quot;alarm_enabled_ctrl_temperature&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;controller_temperature_threshold&quot;</span>:98.0,</span><br><span class="line">      <span class="string">&quot;alarm_enabled_spares&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;spares_threshold&quot;</span>:50,</span><br><span class="line">      <span class="string">&quot;shutdown_state&quot;</span>:<span class="string">&quot;dirty&quot;</span>,</span><br><span class="line">      <span class="string">&quot;shutdown_count&quot;</span>:3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>:<span class="string">&quot;nmem3&quot;</span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面输出中，<code>nmem1</code> 的 <code>shutdown_state</code> 值为 <code>dirty</code>，<code>shutdown_count</code> 值为 <em>3</em>（该值每检测到一次 <em>unsafe shutdown</em> 就增加）。</p>
<p>在 <em>persistent memory</em> 程序中检测 <em>unsafe shutdown</em> 的推荐逻辑如下（与 <em>PMDK</em> 里逻辑相似）：</p>
<ol>
<li>文件创建时：将 <em>namespace</em> 的 <em>UUID</em> 和 <em>namespace</em> 中每个模块的 <em>shutdown</em> 计数存储为元数据</li>
<li>当打开文件时：<ul>
<li>检查 <em>namespace</em> 的 <em>UUID</em>。如果不一致，移动文件。为 <em>namespace</em> 中的每个模块存储新的 <em>UUID</em> 和 <em>shutdown</em> 计数</li>
<li>如果 <em>UUID</em> 相同，检查 <em>shutdown</em> 计数。如果更高，则前一次 <em>shutdown</em> 应视为 <em>unsafe shutdown</em></li>
</ul>
</li>
</ol>
<p><em>libpmemobj-cpp</em> 打开 <em>pool</em> 时，如果检测到 <em>unsafe shutdown</em>，则失败：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./pmem-program /mnt/pmem1/pmem-file</span><br><span class="line">terminate called after throwing an instance of <span class="string">&#x27;pmem::pool_error&#x27;</span></span><br><span class="line">  what():  Failed opening pool: an ADR failure was detected, the pool might be corrupted</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>

<p>在 <em>safe shutdown</em> 后，<code>shutdown_stat</code> 将从 <code>dirty</code> 变为 <code>clean</code>。</p>
<h3 id="2-2-Unsafe-Shutdown-Injection"><a href="#2-2-Unsafe-Shutdown-Injection" class="headerlink" title="2.2 Unsafe Shutdown Injection"></a>2.2 <em>Unsafe Shutdown Injection</em></h3><p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ ndctl inject-smart nmem6 --unsafe-shutdown</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>:<span class="string">&quot;nmem6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="string">&quot;8089-a2-1835-00002529&quot;</span>,</span><br><span class="line">    <span class="string">&quot;handle&quot;</span>:4097,</span><br><span class="line">    <span class="string">&quot;phys_id&quot;</span>:50,</span><br><span class="line">    <span class="string">&quot;security&quot;</span>:<span class="string">&quot;disabled&quot;</span>,</span><br><span class="line">    <span class="string">&quot;health&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;health_state&quot;</span>:<span class="string">&quot;ok&quot;</span>,</span><br><span class="line">      <span class="string">&quot;temperature_celsius&quot;</span>:30.0,</span><br><span class="line">      <span class="string">&quot;controller_temperature_celsius&quot;</span>:31.0,</span><br><span class="line">      <span class="string">&quot;spares_percentage&quot;</span>:100,</span><br><span class="line">      <span class="string">&quot;alarm_temperature&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;alarm_controller_temperature&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;alarm_spares&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;alarm_enabled_media_temperature&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;temperature_threshold&quot;</span>:82.0,</span><br><span class="line">      <span class="string">&quot;alarm_enabled_ctrl_temperature&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;controller_temperature_threshold&quot;</span>:98.0,</span><br><span class="line">      <span class="string">&quot;alarm_enabled_spares&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;spares_threshold&quot;</span>:50,</span><br><span class="line">      <span class="string">&quot;shutdown_state&quot;</span>:<span class="string">&quot;clean&quot;</span>,</span><br><span class="line">      <span class="string">&quot;shutdown_count&quot;</span>:3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>inject-smart</code> 会打印当前监控状况，不包含注入的错误。为使注入显示在输出中，需要关闭系统（简单重启不行）。</p>
<p>移除注入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ndctl inject-smart nmem6 --unsafe-shutdown-uninject</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;dev&quot;</span>:<span class="string">&quot;nmem6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="string">&quot;8089-a2-1835-00002529&quot;</span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2021/05/25/ngx-slab-init/">prev</a><a class="next" href="/2021/04/26/Persistent-Memory-Mode/">next</a></div><div class="copyright"><p>&copy; 2021 <a target="_blank" rel="noopener" href="https://github.com/bigwhite37">bigwhite37</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>